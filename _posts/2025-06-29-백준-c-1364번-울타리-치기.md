---
layout: post
title: "[백준 C++] 1364번 울타리 치기"
description: 백준 1364번 울타리 치기 cpp c++로 풀이
category:
- 프로그래밍
- 백준
tags:
- 백준
- C++
- 수학
author: 최호성
date: 2025-06-29 14:45 +0900
---
# 1364번: 울타리 치기

## 문제 요약
### 문제
육각형 블록들로 이루어진 RPG 세계가 있다. 그 세계에 나라를 세우려고 하는 군주 캐릭터 송유진은 일반 블록을 울타리 블록으로 바꿀 수 있는 아이템을 N개 가지고 있다. 유진이가 이 N개의 아이템을 이용해서 점령할 수 있는 최대의 영토의 넓이를 구해보자. 울타리 안에 둘러싸인 블록들은 당연히 넓이에 포함 시키고, 울타리를 세운 블록도 넓이에 포함을 시킨다. 울타리는 항상 이어져 있어야 하며, 맵의 넓이는 무한하다.

### 사용 알고리즘
수학

### 입출력
- 입력: 첫 줄에는 송유진이 가지고 있는 아이템의 수 N(1≤N≤1,000,000)이 주어진다.
- 출력: N개의 아이템을 이용하여 점령할 수 있는 최대의 블록 수를 출력한다.
```
예제1

입력
6
출력
7
```
## 풀이
수학적인 문제이다. O(1)로 풀수 있다. 중요한점은 n이 무엇이 나오든 육각형 모양으로 울타리를 쳐야 한다는 것이다. 먼저 6으로 나눴을때 몫을 k라고 하고 나머지를 r이라고 하겠다. r이 0이라면 정육각형일때의 넓이를 구하면 된다. r이 1이라면 한 변을 바깥쪽으로 밀 수 있으므로 추가로 k만큼을 더한다. r이 2 이상이라면 이전에 밀어놨던 변의 모서리까지 밀 수 있으므로 k+1만큼 계속 더한다. 

## 어려웠던 점
처음에는 육각형 모양으로 사다리를 치는 것이 아닌 정육각형으로 울타리를 치고 남는것은 옆에 붙이는 식으로 했다가 틀렸다. 

## 배운 점 / 느낀 점
역시 수학은 어렵다. 생각만 잘하면 코드는 쉬운데

## 전체 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

long long n;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> n;
    long long k = n/6;
    long long r = n%6;
    if(r == 0){
        cout << 1+3*k*(k+1);
    }
    else if(r == 1){
        cout << 1+3*k*(k+1)+k;
    }
    else{
        cout << 1+3*k*(k+1)+k+(k+1)*(r-1);
    }

    return 0;
}
```
